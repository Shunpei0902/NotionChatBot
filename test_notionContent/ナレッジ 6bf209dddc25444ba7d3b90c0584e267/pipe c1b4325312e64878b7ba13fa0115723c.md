# pipe

タグ: minishell
作成日: 2024年4月1日
親アイテム: 関数 (%E9%96%A2%E6%95%B0%203a8af7c725b34decb3b5896f15eacd2f.md)
説明: プロセス間通信の基本的な手段を提供する関数

## UNIXおよびUNIX系オペレーティングシステムにおける`pipe`関数

**プロセス間通信の基本的な手段を提供する**

- この関数は、2つのファイルディスクリプタを作成し、片方を書き込み用、もう片方を読み取り用として使用するパイプを生成する。
- これにより、あるプロセスの出力を別のプロセスの入力として直接渡すことができる

### 関数のプロトタイプ

```c
#include <unistd.h>

int pipe(int filedes[2]);
```

- `filedes`: この配列は、パイプの終端を表す2つのファイルディスクリプタを格納します。
- `filedes[0]`は読み取り用、`filedes[1]`は書き込み用です。

### 戻り値

- 成功時には0を返し、`filedes`配列にはパイプの読み取り用と書き込み用のファイルディスクリプタが設定されます。
- 失敗時には-1を返し、`errno`がエラーの原因に応じて設定されます。

### 使用例

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(void) {
    int fd[2];
    pid_t pid;
    char buf[10];

    if (pipe(fd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    } else if (pid == 0) {
        // 子プロセス
        close(fd[1]); // 子プロセスでは書き込み用ディスクリプタを使用しない
        read(fd[0], buf, sizeof(buf)); // 親プロセスからのデータを読み取る
        printf("Received: %s\\n", buf);
        close(fd[0]);
        exit(EXIT_SUCCESS);
    } else {
        // 親プロセス
        close(fd[0]); // 親プロセスでは読み取り用ディスクリプタを使用しない
        write(fd[1], "Hello", 5); // 子プロセスにデータを送信
        close(fd[1]);
    }
    return 0;
}

```

この例では、`pipe`を使用して親プロセスと子プロセス間で文字列`"Hello"`を送信しています。プロセスがフォークされた後、親プロセスはパイプの書き込み端を使用してデータを送信し、子プロセスは読み取り端を使用してデータを受信します。通信が完了した後、使用されなくなったファイルディスクリプタは適切に閉じるべきです。

`pipe`を使用することで、シェルスクリプトにおけるパイプ(`|`)と同様の機能をプログラム内で実現することができます。

# パイプを生成するとは？

**プロセス間でデータを直接渡すための通信チャネルを作ること**

- UNIX系オペレーティングシステムでは、パイプは「無名パイプ」として実装されている
    - これは一時的な、メモリ上に存在するデータストリームで、一方向の通信に使われる
    - パイプに書き込まれたデータは、そのパイプからしか読み出せない

### パイプの動作原理

- **書き込み**: プロセスはパイプの書き込み端にデータを書き込む
    - これは通常、`write()`システムコールを使って行われる
    - **minishellでは、コマンドの出力をリダイレクトする**
- **読み取り**: 別のプロセス（または同じプロセス）はパイプの読み取り端からデータを読み出します。
    - これには`read()`システムコールが使われる
    - **minishellでは、書き込みと同様に、コマンドへの入力をリダイレクトする**

### パイプの生成と使用

パイプは`pipe()`関数を呼び出すことで生成される

この関数は引数として2つの要素を持つ整数型の配列を受け取り、その配列の2つの要素に読み取り端と書き込み端のファイルディスクリプタを設定する

```c
int fds[2];
pipe(fds);
```

このコードが実行されると、`fds[0]`はパイプの読み取り端、`fds[1]`は書き込み端のファイルディスクリプタとなる。

プロセスは`fds[1]`を使ってパイプにデータを書き込み、`fds[0]`を使ってデータを読み出します。

### パイプの利点

パイプは複数のプロセス間でデータを直接やり取りするためのシンプルかつ効率的な手段を提供する

特に、データを一時的に他のプロセスに渡したい場合や、プロセスの出力を別のプロセスの入力として使いたい場合に便利

### 使用例

コマンドラインで`|`記号を使用する場合（例：`ls | grep txt`）も、シェルが裏でパイプを作成し、`ls`コマンドの出力を`grep`コマンドの入力として渡しているのと同じ原理です。プログラミングにおいても、パイプを利用することで同様のデータの受け渡しが可能になります。

# closeについて

### パイプとEOFの検出

<aside>
💡 Unix系オペレーティングシステムにおいて、パイプを介した通信では、読み込み側はパイプからデータを読み取るが、書き込み側のすべてのプロセスがパイプの書き込み用エンドを閉じた時点で初めてEOFを検出する。

つまり、少なくとも一つのプロセスが書き込み用エンドを開いた状態にしていると、読み込み側はEOFが到達したと判断できず、データがまだ到来するかのように待機し続ける。

</aside>

### 不要なエンドを開いたままにしておくと、リソースの無駄遣いだけでなく、プログラムがデッドロックに陥る原因になる

- 子プロセスと親プロセスはメモリ空間を共有しない
    
    → それぞれが独立してファイル記述子を管理する
    
    - `fork()`によって子プロセスが作成されると、その時点で親プロセスが開いているファイル記述子が子プロセスにコピーされる（パイプのファイル記述子も含まれる）
        
        → 子プロセスで閉じたとしても親プロセスには影響しない